---
title: JAVA 面向对象 （二）
date: 2019-04-25 08:57:58
tags: github
---

### **1.package:**
  **1)作用:避免类的命名冲突**
  **2)包名可以有层次结构 类的全称: 包名.类名**
  **3)同包中的类不能同名**
  **4)建议:包名所有字母都小写**

  #### **import:**
  **1)同包中的类可以直接访问，**
​     **不同包中的类不能直接访问，想访问如下两种方式:**
     **1.先import声明类再使用类-------建议**
     **2.类的全称---------------太繁琐，不建议**

### **2.访问控制修饰符:**
  **1)public:公开的，任何类**
  **2)private:私有的，本类**
  **3)protected:受保护的，本类、派生类、同包类**
  **4)默认的:什么也不写，本类、同包类**
  **说明:**
​    **1)类的访问控制修饰符只能是public和默认的**
​    **2)类中成员的访问控制修饰符如上4种都可以**

### **3.final:最终的、不可改变的-----单独应用率极低**
  **1)修饰变量:变量不能被改变**
  **2)修饰方法:方法不能被重写**
  **3)修饰类:类不能被继承**

### **4.static:静态的**
  **1)静态变量:**
​      **1.由static修饰**
​      **2.属于类，存在方法区中，只有一份**
​      **3.常常通过类名点来访问**
​      **4.何时用:所有对象所共享的数据(图片、音频、视频等)**
  **2)静态方法:**
​      **1.由static修饰**
​      **2.属于类，存在方法区中，只有一份**
​      **3.常常通过类名点来访问**
​      **4.静态方法没有隐式this传递的，**
​         **在静态方法中不能直接访问实例成员**
​      **5.何时用:方法的操作仅与参数相关而与对象无关时**
  **3)静态块:**
​      **1.由static修饰**
​      **2.属于类，在类被加载期间自动执行，**
​          **因类只被加载一次，所以静态块只执行一次**
​      **3.何时用:加载/初始化静态资源(图片、音频、视频等)**

### **5.static final常量:**
  **1)必须声明同时初始化**
  **2)由类名点来访问，并且不能被改变**
  **3)建议:常量名所有字母都大写，多个单词用_分隔**
  **4)编译器在编译时将常量直接替换为具体的值，效率高**
  **5)何时用:数据永远不变、并且经常使用**

### **6.抽象方法:**
  **1)由abstract修饰**
  **2)只有方法的定义，没有具体的实现(连{}都没有)**

### **7.抽象类:**
  **1)由abstract修饰**
  **2)包含抽象方法的类必须是抽象类**
​      **不包含抽象方法的类也可以声明为抽象类**
  **3)抽象类不能被实例化**
  **4)抽象类是需要被继承的，派生类:**
​      **1.重写所有抽象方法--------常用**
​      **2.也声明为抽象类-------一般不这么做**
  **5)抽象类的意义:**
​      **1.封装派生类所共有的属性和行为---------代码复用**
​      **2.给所有派生类提供统一的类型------------向上造型**
​      **3.可以包含抽象方法，为所有派生类提供统一的入口**
​          **派生类的具体行为不同，但入口是一致的**

### **8.成员内部类:应用率低**
​     **问:内部类有独立的.class吗?**
​     **答:有**
  **1)类中套类，外面的称为Outer外部类，里面的称为Inner内部类**
  **2)内部类通常只服务于外部类，对外不具备可见性**
  **3)内部类对象通常是在外部类中创建的**
  **4)内部类中可以直接访问外部类的成员(包括私有的)**
​      **内部类中有个隐式的引用指向了创建它的外部类对象**

### **9.匿名内部类:应用率高**
  **1)若想创建了一个类(派生类)的对象，并且对象只被创建一次，**
​      **此时该类不必命名，称为匿名内部类**
  **2)匿名内部类中若想访问外部的变量，该变量必须是的final的**
​    **-----在JDK1.8之前有这样的要求**

### **10.接口:**
  **1)是一种数据类型(引用类型)**
  **2)由interface定义**
  **3)只能包含常量和抽象方法**
  **4)接口不能被实例化**
  **5)接口是需要被实现/继承的，实现类/派生类:**
​      **必须重写接口中的所有抽象方法**
  **6)一个类可以实现多个接口，用逗号隔开**
​      **若又继承又实现时，必须先继承后实现**
  **7)接口可以继承接口**

#### **设计规则:** 
**1)将所有派生类所共有的属性和行为，抽到超类中--------抽共性**
**2)所有派生类的行为都一样，设计为普通方法**
   **所有派生类的行为都不一样，设计为抽象方法**
**3)将部分派生类所共有的行为，抽到接口中**
  **接口是对继承单根性的扩展-------------实现多继承**
  **符合 既是 也是 原则时，使用接口**

### **11.多态:**
  **1)意义:**
​    **1.同一类型的引用，指向不同的对象时，有不同的实现**
​        **----行为的多态:cut()、run()、step()、getImage()...**
​    **2.同一个对象，被造型为不同的类型时，有不同的功能**
​        **----对象的多态:水、我...**
  **2)向上造型/自动类型转换:**
​     **1.超类型的引用指向派生类的对象**
​     **2.能造型成为的数据类型有: 超类+所实现的接口**
​     **3.能点出来什么，看引用的类型**
  **3)强制类型转换，成功的条件只有如下两种:**
​     **1.引用所指向的对象，就是该类型**
​     **2.引用所指向的对象，继承了该类或实现了该接口**
  **4)强转时若不符合如上条件，则发生ClassCastException类型转换异常**
​      **建议:在强转之前先通过instanceof来判断引用的对象是否是该类型**

### **12.内存管理:由JVM来管理的**
  **1)堆:**
​    **1.存储new出来的对象(包括实例变量)**
​    **2.垃圾:没有任何引用所指向的对象**
​        **垃圾回收器(GC)不定时到内存中清理垃圾，**
​        **回收过程是透明的(看不到的)，不一定一发现垃圾就立刻回收，**
​        **调用System.gc()可以建议虚拟机尽快调度GC来回收**
​    **3.内存泄漏:不再使用的内存没有被及时的回收**
​        **建议:对象不再使用时及时将引用设置为null**
​    **4.实例变量的生命周期:**
​       **在创建对象时存储在堆中，对象被回收时一并被回收**
  **2)栈:**
​    **1.存储正在调用的方法中的所有局部变量(包括方法的参数)**
​    **2.调用方法时，会在栈中为该方法分配一块对应的栈帧，**
​       **栈帧中存储方法中的局部变量(包括参数)，**
​       **方法调用结束时，栈帧被清除，局部变量一并被清除**
​    **3.局部变量的生命周期:**
​       **方法被调用时存储在栈中，方法结束时与栈帧一并被清除**
  **3)方法区:**
​    **1.存储.class字节码文件(包括静态变量、方法)**
​    **2.方法只有一份，通过this来区分具体的调用对象**

### **面向对象三大特征:**
**1.封装:**
  **1)类:封装的是对象的属性和行为**
  **2)方法:封装的是特定的业务逻辑功能**
  **3)访问控制修饰符:封装的是具体的访问权限**
**2.继承:**
  **1)作用:代码复用**
  **2)超类:所有派生类所共有的属性和行为**
​      **接口:部分派生类所共有的行为**
​      **派生类:派生类所特有的属性和行为**
  **3)单一继承、多接口实现，传递性**
**3.多态:**
  **1)意义:行为的多态(所有抽象方法都是多态的)**
​              **对象的多态(所有对象都是多态的)**
  **2)向上造型、强制类型转换、instanceof判断**
  **3)多态的表现形式:**
​      **1.重写:根据对象的不同来表现多态**
​      **2.重载:根据参数的不同来表现多态**

