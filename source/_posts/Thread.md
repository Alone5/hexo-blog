---
title: Thread-1
date: 2019-05-20 18:28:27
tags: github
---
### JAVA 多线程
#### 简介
- **Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。**
- **这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。**
- **多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。**

#### 线程的几个主要概念
1. **线程同步**
2. **线程间通信**
3. **线程死锁**
4. **线程控制：挂起、停止和恢复**

#### 进程与线程的区别
- **简而言之,一个程序至少有一个进程,一个进程至少有一个线程. **
- **线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。**
- **线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。**
- **进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.**
- **线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行**
- **进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。**

#### 多线程的使用
- **有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！**

#### 并发原理
- **多个线程“同时”运行只是我们感观上的一种表现。事实上线程是并发运行的，操作系统将时间划分为很多时间段，尽可能的均匀分配给每一个线程，获取到时间片的线程被CPU执行，其他则一直在等待。所以微观上是走走停停，宏观上都在运行。这种现象叫并发，但不是绝对意义上的同时发生。实则操作系统里面“同一时刻”只有一个线程在执行，但是处理速率快，效果上是并发运行。**

#### 线程的优先级
- **每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。**
- **Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。**
- **具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。**

#### 创建线程的三种方式
- **通过实现 Runnable 接口；**
- **通过继承 Thread 类本身；**
- **通过 Callable 和 Future 创建线程。**
1. **通过实现Runnable接口创建线程**
	- **实现Runnable接口并重写run方法来定义线程体，然后在创建线程的时候将Runnable的实例传入并启动线程。这样做的好处在于将线程和线程执行的任务分离开解耦合。同时Java是单继承，实现接口可以更好的让该类去继承其他类。**
2. **通过继承Thread来创建线程**
	- **创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。**

##### Thread类的一些重要方法：
- **测试线程是否处于活动状态。 被Thread对象调用的。**
	- **public void start()**
		- **使该线程开始执行；Java 虚拟机调用该线程的 run 方法。**
	- **public void run()**
		- **如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。**
	- **public final void setName(String name)**
		- **改变线程名称，使之与参数 name 相同。**
	- **public final void setPriority(int priority)**
		- **更改线程的优先级。**
	- **public final void setDaemon(boolean on)**
		- **将该线程标记为守护线程或用户线程。**
	- **public final void join(long millisec)**
		- **等待该线程终止的时间最长为 millis 毫秒。**
	- **public void interrupt()**
		- **中断线程。**
	- **public final boolean isAlive()**
		- **测试线程是否处于活动状态。**

- **Thread类的静态方法：**
	- **public static void yield()**
		- **暂停当前正在执行的线程对象，并执行其他线程。**
	- **public static void sleep(long millisec)**
		- **在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。**
	- **public static boolean holdsLock(Object x)**
		- **当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。**
	- **public static Thread currentThread()**
		- **返回对当前正在执行的线程对象的引用。**
	- **public static void dumpStack()**
		- **将当前线程的堆栈跟踪打印至标准错误流。**

3. **通过 Callable 和 Future 创建线程**
	- **创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。**
	- **创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。**
	- **使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。**
	- **调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。**

#### 创建线程的三种方式的对比
- **采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。**
- **使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。**

